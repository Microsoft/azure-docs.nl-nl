---
title: Nuttige diagnostische query's-grootschalige (Citus)-Azure Database for PostgreSQL
description: Query's voor meer informatie over gedistribueerde gegevens en meer
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: how-to
ms.date: 1/5/2021
ms.openlocfilehash: 4858f650aca1b704ac79482e0158fd83fc0264b8
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 03/19/2021
ms.locfileid: "98165238"
---
# <a name="useful-diagnostic-queries"></a>Nuttige diagnostische Query's

## <a name="finding-which-node-contains-data-for-a-specific-tenant"></a>Zoeken welk knoop punt gegevens bevat voor een specifieke Tenant

In het geval van multi tenant gebruik kunnen we bepalen welk worker-knoop punt de rijen voor een specifieke Tenant bevat.  Grootschalige (Citus) groepeert de rijen van gedistribueerde tabellen in Shards en plaatst elke Shard op een werk knooppunt in de Server groep. 

Stel dat de tenants van de toepassing zijn opgeslagen en dat we willen weten welk worker-knoop punt de gegevens voor Store ID = 4 bevat.  Met andere woorden, we willen de plaatsing van de Shard die rijen bevatten waarvan de distributie kolom de waarde 4 heeft:

``` postgresql
SELECT shardid, shardstate, shardlength, nodename, nodeport, placementid
  FROM pg_dist_placement AS placement,
       pg_dist_node AS node
 WHERE placement.groupid = node.groupid
   AND node.noderole = 'primary'
   AND shardid = (
     SELECT get_shard_id_for_distribution_column('stores', 4)
   );
```

De uitvoer bevat de host en poort van de worker-data base.

```
┌─────────┬────────────┬─────────────┬───────────┬──────────┬─────────────┐
│ shardid │ shardstate │ shardlength │ nodename  │ nodeport │ placementid │
├─────────┼────────────┼─────────────┼───────────┼──────────┼─────────────┤
│  102009 │          1 │           0 │ 10.0.0.16 │     5432 │           2 │
└─────────┴────────────┴─────────────┴───────────┴──────────┴─────────────┘
```

## <a name="finding-the-distribution-column-for-a-table"></a>De kolom distributie voor een tabel zoeken

Elke gedistribueerde tabel in grootschalige (Citus) heeft een ' distributie kolom '. (Zie [gedistribueerde gegevens modellering](concepts-hyperscale-choose-distribution-column.md)voor meer informatie.) Het kan belang rijk zijn om te weten welke kolom het is. Als u bijvoorbeeld tabellen samenvoegt of filtert, worden er fout berichten weer geven met hints zoals ' een filter toevoegen aan de kolom distributie '.

De `pg_dist_*` tabellen op het coördinator knooppunt bevatten diverse meta gegevens over de gedistribueerde data base. Bevat met name `pg_dist_partition` informatie over de kolom distributie voor elke tabel. U kunt een handige functie van het hulp programma gebruiken om de naam van de distributie kolom op te zoeken van de details op laag niveau in de meta gegevens. Hier volgt een voor beeld en de uitvoer:

``` postgresql
-- create example table

CREATE TABLE products (
  store_id bigint,
  product_id bigint,
  name text,
  price money,

  CONSTRAINT products_pkey PRIMARY KEY (store_id, product_id)
);

-- pick store_id as distribution column

SELECT create_distributed_table('products', 'store_id');

-- get distribution column name for products table

SELECT column_to_column_name(logicalrelid, partkey) AS dist_col_name
  FROM pg_dist_partition
 WHERE logicalrelid='products'::regclass;
```

Voorbeelduitvoer:

```
┌───────────────┐
│ dist_col_name │
├───────────────┤
│ store_id      │
└───────────────┘
```

## <a name="detecting-locks"></a>Vergren delingen detecteren

Deze query wordt uitgevoerd op alle worker-knoop punten en identificeert de vergren delingen, hoe lang ze zijn geopend en de conflicterende query's:

``` postgresql
SELECT run_command_on_workers($cmd$
  SELECT array_agg(
    blocked_statement || ' $ ' || cur_stmt_blocking_proc
    || ' $ ' || cnt::text || ' $ ' || age
  )
  FROM (
    SELECT blocked_activity.query    AS blocked_statement,
           blocking_activity.query   AS cur_stmt_blocking_proc,
           count(*)                  AS cnt,
           age(now(), min(blocked_activity.query_start)) AS "age"
    FROM pg_catalog.pg_locks         blocked_locks
    JOIN pg_catalog.pg_stat_activity blocked_activity
      ON blocked_activity.pid = blocked_locks.pid
    JOIN pg_catalog.pg_locks         blocking_locks
      ON blocking_locks.locktype = blocked_locks.locktype
     AND blocking_locks.DATABASE IS NOT DISTINCT FROM blocked_locks.DATABASE
     AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
     AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
     AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
     AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
     AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
     AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
     AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
     AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
     AND blocking_locks.pid != blocked_locks.pid
    JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
    WHERE NOT blocked_locks.GRANTED
     AND blocking_locks.GRANTED
    GROUP BY blocked_activity.query,
             blocking_activity.query
    ORDER BY 4
  ) a
$cmd$);
```

Voorbeelduitvoer:

```
┌───────────────────────────────────────────────────────────────────────────────────┐
│                               run_command_on_workers                              │
├───────────────────────────────────────────────────────────────────────────────────┤
│ (10.0.0.16,5432,t,"")                                                             │
│ (10.0.0.20,5432,t,"{""update ads_102277 set name = 'new name' where id = 1; $ sel…│
│…ect * from ads_102277 where id = 1 for update; $ 1 $ 00:00:03.729519""}")         │
└───────────────────────────────────────────────────────────────────────────────────┘
```

## <a name="querying-the-size-of-your-shards"></a>Query's uitvoeren op de grootte van uw Shards

Met deze query krijgt u de grootte van elke Shard van een bepaalde gedistribueerde tabel, met de naam `my_distributed_table` :

``` postgresql
SELECT *
FROM run_command_on_shards('my_distributed_table', $cmd$
  SELECT json_build_object(
    'shard_name', '%1$s',
    'size',       pg_size_pretty(pg_table_size('%1$s'))
  );
$cmd$);
```

Voorbeelduitvoer:

```
┌─────────┬─────────┬───────────────────────────────────────────────────────────────────────┐
│ shardid │ success │                                result                                 │
├─────────┼─────────┼───────────────────────────────────────────────────────────────────────┤
│  102008 │ t       │ {"shard_name" : "my_distributed_table_102008", "size" : "2416 kB"}    │
│  102009 │ t       │ {"shard_name" : "my_distributed_table_102009", "size" : "3960 kB"}    │
│  102010 │ t       │ {"shard_name" : "my_distributed_table_102010", "size" : "1624 kB"}    │
│  102011 │ t       │ {"shard_name" : "my_distributed_table_102011", "size" : "4792 kB"}    │
└─────────┴─────────┴───────────────────────────────────────────────────────────────────────┘
```

## <a name="querying-the-size-of-all-distributed-tables"></a>Query's uitvoeren op de grootte van alle gedistribueerde tabellen

Met deze query wordt een lijst opgehaald met de grootten voor elke gedistribueerde tabel plus de grootte van de indices.

``` postgresql
SELECT
  tablename,
  pg_size_pretty(
    citus_total_relation_size(tablename::text)
  ) AS total_size
FROM pg_tables pt
JOIN pg_dist_partition pp
  ON pt.tablename = pp.logicalrelid::text
WHERE schemaname = 'public';
```

Voorbeelduitvoer:

```
┌───────────────┬────────────┐
│   tablename   │ total_size │
├───────────────┼────────────┤
│ github_users  │ 39 MB      │
│ github_events │ 98 MB      │
└───────────────┴────────────┘
```

Houd er rekening mee dat er andere grootschalige-functies (Citus) zijn voor het uitvoeren van query's in de gedistribueerde tabel grootte, Zie [tabel grootte bepalen](howto-hyperscale-table-size.md).

## <a name="identifying-unused-indices"></a>Ongebruikte indices identificeren

Met de volgende query worden ongebruikte indexen op werk knooppunten voor een bepaalde gedistribueerde tabel ( `my_distributed_table` ) geïdentificeerd

``` postgresql
SELECT *
FROM run_command_on_shards('my_distributed_table', $cmd$
  SELECT array_agg(a) as infos
  FROM (
    SELECT (
      schemaname || '.' || relname || '##' || indexrelname || '##'
                 || pg_size_pretty(pg_relation_size(i.indexrelid))::text
                 || '##' || idx_scan::text
    ) AS a
    FROM  pg_stat_user_indexes ui
    JOIN  pg_index i
    ON    ui.indexrelid = i.indexrelid
    WHERE NOT indisunique
    AND   idx_scan < 50
    AND   pg_relation_size(relid) > 5 * 8192
    AND   (schemaname || '.' || relname)::regclass = '%s'::regclass
    ORDER BY
      pg_relation_size(i.indexrelid) / NULLIF(idx_scan, 0) DESC nulls first,
      pg_relation_size(i.indexrelid) DESC
  ) sub
$cmd$);
```

Voorbeelduitvoer:

```
┌─────────┬─────────┬───────────────────────────────────────────────────────────────────────┐
│ shardid │ success │                            result                                     │
├─────────┼─────────┼───────────────────────────────────────────────────────────────────────┤
│  102008 │ t       │                                                                       │
│  102009 │ t       │ {"public.my_distributed_table_102009##some_index_102009##28 MB##0"}   │
│  102010 │ t       │                                                                       │
│  102011 │ t       │                                                                       │
└─────────┴─────────┴───────────────────────────────────────────────────────────────────────┘
```

## <a name="monitoring-client-connection-count"></a>Aantal client verbindingen controleren

Met de volgende query worden de verbindingen geteld die zijn geopend op de coördinator en worden deze gegroepeerd op type.

``` sql
SELECT state, count(*)
FROM pg_stat_activity
GROUP BY state;
```

Voorbeelduitvoer:

```
┌────────┬───────┐
│ state  │ count │
├────────┼───────┤
│ active │     3 │
│ idle   │     3 │
│ ∅      │     6 │
└────────┴───────┘
```

## <a name="index-hit-rate"></a>Aantal treffers voor index

Deze query geeft u de frequentie van het aantal treffers op alle knoop punten. Het aantal treffers in de index is handig om te bepalen hoe vaak indices worden gebruikt bij het uitvoeren van query's:

``` postgresql
SELECT nodename, result as index_hit_rate
FROM run_command_on_workers($cmd$
  SELECT CASE sum(idx_blks_hit)
    WHEN 0 THEN 'NaN'::numeric
    ELSE to_char((sum(idx_blks_hit) - sum(idx_blks_read)) / sum(idx_blks_hit + idx_blks_read), '99.99')::numeric
    END AS ratio
  FROM pg_statio_user_indexes
$cmd$);
```

Voorbeelduitvoer:

```
┌───────────┬────────────────┐
│ nodename  │ index_hit_rate │
├───────────┼────────────────┤
│ 10.0.0.16 │ 0.88           │
│ 10.0.0.20 │ 0.89           │
└───────────┴────────────────┘
```

## <a name="cache-hit-rate"></a>Aantal treffers in cache

De meeste toepassingen gebruiken meestal een kleine fractie van de totale gegevens tegelijk. PostgreSQL houdt regel matig toegang tot gegevens in het geheugen om trage Lees bewerkingen van de schijf te voor komen. U kunt statistieken hierover bekijken in de weer gave [pg_statio_user_tables](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STATIO-ALL-TABLES-VIEW) .

Een belang rijke meting is welk percentage van de gegevens afkomstig is uit de geheugen cache versus de schijf in uw workload:

``` postgresql
SELECT
  sum(heap_blks_read) AS heap_read,
  sum(heap_blks_hit)  AS heap_hit,
  sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) AS ratio
FROM
  pg_statio_user_tables;
```

Voorbeelduitvoer:

```
 heap_read | heap_hit |         ratio
-----------+----------+------------------------
         1 |      132 | 0.99248120300751879699
```

Als u een ratio hebt gevonden die aanzienlijk lager is dan 99%, wilt u waarschijnlijk overwegen om de beschik bare cache voor uw data base te verg Roten.

## <a name="next-steps"></a>Volgende stappen

* Meer informatie over andere [systeem tabellen](reference-hyperscale-metadata.md) die nuttig zijn voor diagnostische gegevens
